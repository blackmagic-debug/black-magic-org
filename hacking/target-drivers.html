<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="../_static/favicon/icon.svg">
    <link rel="icon" sizes="16x16" type="image/png" href="../_static/favicon/favicon-16x16.png">
    <link rel="icon" sizes="32x32" type="image/png" href="../_static/favicon/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="57x57" type="image/png" href="../_static/favicon/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" type="image/png" href="../_static/favicon/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" type="image/png" href="../_static/favicon/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" type="image/png" href="../_static/favicon/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="96x96" type="image/png" href="../_static/favicon/apple-touch-icon-96x96.png">
    <link rel="apple-touch-icon" sizes="114x114" type="image/png" href="../_static/favicon/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" type="image/png" href="../_static/favicon/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" type="image/png" href="../_static/favicon/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" type="image/png" href="../_static/favicon/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" type="image/png" href="../_static/favicon/apple-touch-icon-180x180.png">
    <link rel="android-icon" sizes="192x192" type="image/png" href="../_static/favicon/android-icon-192x192.png"><meta property="og:title" content="Adding Target Drivers" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://black-magic.org/hacking/target-drivers.html" />
<meta property="og:site_name" content="Black Magic Debug" />
<meta property="og:description" content="External target API: You can find the public API in target.h, used by the GDB server. Nothing defined in src/target outside of this header should be accessed from outside of src/target/* Internal t..." />
<meta property="og:image" content="https://black-magic.org/_static/blackmagic-logo.png" />
<meta property="og:image:alt" content="Black Magic Debug" />
<meta name="description" content="External target API: You can find the public API in target.h, used by the GDB server. Nothing defined in src/target outside of this header should be accessed from outside of src/target/* Internal t..." />

    <title>Adding Target Drivers &#8212; Black Magic Debug  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=039e1c02" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../_static/asciinema-player_2.6.1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/asciinema-custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/platformpicker.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=16ad857a"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/asciinema-player_2.6.1.js"></script>
    <script src="../_static/platformpicker.js"></script>
    <link rel="canonical" href="https://black-magic.org/hacking/target-drivers.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Cortex-M Targets" href="target-cortex-m.html" />
    <link rel="prev" title="Firmware Hacking" href="hacking.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />


<link
  rel="alternate"
  type="application/atom+xml"
  href="../blog/atom.xml"
  title="Blog"
/>



  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
<section id="adding-target-drivers">
<h1>Adding Target Drivers<a class="headerlink" href="#adding-target-drivers" title="Permalink to this heading">¶</a></h1>
<section id="external-target-api">
<h2>External target API<a class="headerlink" href="#external-target-api" title="Permalink to this heading">¶</a></h2>
<p>You can find the public API in <a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/include/target.h"><code class="docutils literal notranslate"><span class="pre">target.h</span></code></a>, used by the GDB server. Nothing defined in <code class="docutils literal notranslate"><span class="pre">src/target</span></code> outside of this header should be accessed from outside of <code class="docutils literal notranslate"><span class="pre">src/target/*</span></code></p>
</section>
<section id="internal-target-api">
<h2>Internal target API<a class="headerlink" href="#internal-target-api" title="Permalink to this heading">¶</a></h2>
<p>There are several internal API headers:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/target_internal.h"><code class="docutils literal notranslate"><span class="pre">target/target_internal.h</span></code></a>
This header contains structure definitions and convenience functions for use in target support implementations.
Specific target implementations fill in the function pointers in these structures for their device specific
implementations.</p></li>
<li><p><a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/target_probe.h"><code class="docutils literal notranslate"><span class="pre">target/target_probe.h</span></code></a>
This header contains declarations for all the *_probe functions so they’re all declared in one central place.
This header works in tandem with <code class="docutils literal notranslate"><span class="pre">target/target_probe.c</span></code> to allow any target support implementation to be
switched off as-needed without this breaking the build.</p></li>
</ul>
</section>
<section id="raw-jtag-devices">
<h2>Raw JTAG Devices<a class="headerlink" href="#raw-jtag-devices" title="Permalink to this heading">¶</a></h2>
<p>Supported JTAG devices are defined in <a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/jtag_devs.c">target/jtag_devs.c</a></p>
<p>The <code class="docutils literal notranslate"><span class="pre">.handler</span></code> function is called when a device’s ID Code matches the <code class="docutils literal notranslate"><span class="pre">.idcode</span></code> field with <code class="docutils literal notranslate"><span class="pre">.idmask</span></code> applied.
It is the responsibility of the handler function to instantiate a new target with <code class="docutils literal notranslate"><span class="pre">target_new</span></code> and fill in
the access function pointers.</p>
<section id="raw-jtag-access">
<h3>Raw JTAG access<a class="headerlink" href="#raw-jtag-access" title="Permalink to this heading">¶</a></h3>
<p>There is a global structure of function pointers, <code class="docutils literal notranslate"><span class="pre">jtag_proc</span></code> defined in
<a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/include/jtagtap.h"><code class="docutils literal notranslate"><span class="pre">jtagtap.h</span></code></a>, which is
automatically initialised to provide access to raw JTAG bus access routines:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">jtag_proc</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* Reset the bus */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">jtagtap_reset</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Step into the next TMS state */</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">jtagtap_next</span><span class="p">)(</span><span class="kt">bool</span><span class="w"> </span><span class="n">tms</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">tdi</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Step through a sequence of TMS states (up to 32) */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">jtagtap_tms_seq</span><span class="p">)(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">tms_states</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">clock_cycles</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Write a number of bits from data_in to TDI, reading the responses back into data_out from TDO */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">jtagtap_tdi_tdo_seq</span><span class="p">)(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">data_out</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">final_tms</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">data_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">clock_cycles</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Same as the previous function but without the read-back part */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">jtagtap_tdi_seq</span><span class="p">)(</span><span class="kt">bool</span><span class="w"> </span><span class="n">final_tms</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">data_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">clock_cycles</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Runs a series of clock cycles on the bus after establishing an initial TMS + TDI state */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">jtagtap_cycle</span><span class="p">)(</span><span class="kt">bool</span><span class="w"> </span><span class="n">tms</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">tdi</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">clock_cycles</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="n">jtag_proc_s</span><span class="p">;</span>
</pre></div>
</div>
<p>There are also some helper macros defined for running certain known sequences onto the bus:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Perform a soft reset of the bus */</span>
<span class="cp">#define jtagtap_soft_reset() jtag_proc.jtagtap_tms_seq(0x1fU, 6U)</span>
<span class="cm">/* From bus idle, clock into the Shift-IR state */</span>
<span class="cp">#define jtagtap_shift_ir() jtag_proc.jtagtap_tms_seq(0x03U, 4U)</span>
<span class="cm">/* From bus idle, clock into the Shift-DR state */</span>
<span class="cp">#define jtagtap_shift_dr() jtag_proc.jtagtap_tms_seq(0x01U, 3U)</span>
<span class="cm">/* Return the bus to idle from one of the capture states */</span>
<span class="cp">#define jtagtap_return_idle(cycles) jtag_proc.jtagtap_tms_seq(0x01U, (cycles) + 1U)</span>
</pre></div>
</div>
</section>
<section id="tap-layer-access">
<h3>TAP-layer access<a class="headerlink" href="#tap-layer-access" title="Permalink to this heading">¶</a></h3>
<p>There are higher level access functions defined in
<a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/jtag_scan.h"><code class="docutils literal notranslate"><span class="pre">target/jtag_scan.h</span></code></a>.</p>
<p>These functions provide higher level access to the JTAG IR and DR registers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Write the dev_index&#39;th device&#39;s IR to the value in `ir` */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">jtag_dev_write_ir</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">dev_index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ir</span><span class="p">);</span>
<span class="cm">/*</span>
<span class="cm"> * Write the dev_index&#39;th device&#39;s DR with the data sequence pointed to by data_in,</span>
<span class="cm"> * Reading the current DR value back in data_out. Either can be NULL to allow only-readout and only-write operations.</span>
<span class="cm"> */</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">jtag_dev_shift_dr</span><span class="p">(</span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">dev_index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">data_out</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="n">data_in</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">clock_cycles</span><span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="arm-implementations-adiv5">
<h2>ARM implementations (ADIv5)<a class="headerlink" href="#arm-implementations-adiv5" title="Permalink to this heading">¶</a></h2>
<p>There are a few moving parts to the ADIv5 (ARM Debug Interface v5) implementation. The most important ones are:</p>
<ul class="simple">
<li><p>The debug interface logic itself found in
<a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/adiv5.c"><code class="docutils literal notranslate"><span class="pre">target/adiv5.c</span></code></a>.</p></li>
<li><p>The generic logic for Cortex-M parts which is found in
<a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/cortexm.c"><code class="docutils literal notranslate"><span class="pre">target/cortexm.c</span></code></a>.
Please note, this presently supports the ARMv6-M and ARMv7-M profiles only.</p></li>
<li><p>The generic logic for Cortex-A parts which is found in
<a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/cortexa.c"><code class="docutils literal notranslate"><span class="pre">target/cortexa.c</span></code></a>.
Please note, this presently supports the ARMv7-M profile only.</p></li>
</ul>
<section id="adiv5-coresight-identification">
<h3>ADIv5 Coresight identification<a class="headerlink" href="#adiv5-coresight-identification" title="Permalink to this heading">¶</a></h3>
<p><code class="docutils literal notranslate"><span class="pre">adiv5.c</span></code> implements not just logic for accessing the Debug Port and Access Port components of an ADIv5 Coresight
interface over either JTAG or SWD, but also implements the generic identification logic for devices using this
specification.</p>
<p>When a device is identified during scan that talks ADIv5, the various Coresight CIDR and PIDR values get read out
automatically and decoded. A list of known component class values can be found at the top of <code class="docutils literal notranslate"><span class="pre">adiv5.c</span></code> and
a list of known JEP-106 manufacturer codes (encoded in the PIDR register for each ROM table chunk that must be read)
can be found in the <a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/adiv5.h"><code class="docutils literal notranslate"><span class="pre">target/adiv5.h</span></code></a>
header.</p>
<p>Once an AP has been identified as belonging to either a Cortex-M or a Cortex-A core, the ADIv5 code dispatches to
<code class="docutils literal notranslate"><span class="pre">cortexm_probe</span></code> or <code class="docutils literal notranslate"><span class="pre">cortexa_probe</span></code> accordingly.</p>
</section>
<section id="cortex-m-device-handling">
<h3>Cortex-M device handling<a class="headerlink" href="#cortex-m-device-handling" title="Permalink to this heading">¶</a></h3>
<p>Special consideration is made for ARM’s JEP-106 which represents an ARM Cortex device which has not had its ROM
tables customised by the device manufacturer. When the Cortex-M support encounters a device like this in
<code class="docutils literal notranslate"><span class="pre">cortexm_probe</span></code>, the ARM part ID retrieved from the ROM tables is used to identify which type of Cortex-M core
is being probed, and further part identification is then dispatched on the core type.</p>
<p>In either this case or the normal manufacturer-specific JEP-106 case, we then dispatch to one of a number of <code class="docutils literal notranslate"><span class="pre">_probe</span></code>
routines that are then used to specifically identify the part and, on creating a positive part identification,
configure any device-specific behaviour that needs to occur via the <code class="docutils literal notranslate"><span class="pre">target_s</span></code> structure, and if possible
define any known RAM and Flash memory regions via <code class="docutils literal notranslate"><span class="pre">target_add_ram</span></code> and <code class="docutils literal notranslate"><span class="pre">target_add_flash</span></code> (the latter typically
gets wrapped in a target-specific helper).</p>
<p>Once a probe routine creates a positive identification on a part and configures the target structure and memory
regions, it must return <code class="docutils literal notranslate"><span class="pre">true</span></code> to halt the probing process for the AP. If a probe routine fails to create a positive
identification, it must return <code class="docutils literal notranslate"><span class="pre">false</span></code> as soon as possible.</p>
</section>
</section>
<section id="flash-programming">
<h2>Flash programming<a class="headerlink" href="#flash-programming" title="Permalink to this heading">¶</a></h2>
<p>None of the generic targets are able to provide a generic way to erase or write Flash, as this is implemented
differently for each target device. Instead, as part of the writing target support, you must supply suitable Flash
erase and write routines. The target layer then interacts with the Flash of your target through these routines,
which may even be specific to specific Flash regions depending on how the Flash/NVM controller in the target
device works.</p>
<p>Configuration of these routines is achieved by constructing <code class="docutils literal notranslate"><span class="pre">target_flash_s</span></code> structures, the layout of which is
provided below with member documentation. Once the structure has been filled in with the necessary information
for the target Flash region, <code class="docutils literal notranslate"><span class="pre">target_add_flash</span></code> must then be called to register the region against the target.</p>
<p>If your target requires additional data not present in the <code class="docutils literal notranslate"><span class="pre">target_flash_s</span></code> structure, it is permitted to
write a structure that wraps <code class="docutils literal notranslate"><span class="pre">target_flash_s</span></code> to add the additional members needed. An example of this for the
RP2040 support follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rp_flash</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* This member is what gets passed to `target_add_flash` to register the region */</span>
<span class="w">    </span><span class="n">target_flash_s</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * RP2040 being Flashless can have an arbitrary Flash programming page size based on the attached</span>
<span class="cm">     * SPI Flash device, this field stores what that discovered size is for use in write operations</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">page_size</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* Likewise the instruction to issue to the SPI Flash to erase a sector is device-specific */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">sector_erase_opcode</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">rp_flash_s</span><span class="p">;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">rp_add_flash</span><span class="p">(</span><span class="n">target_s</span><span class="w"> </span><span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Allocate the device-specific structure on the heap (this allocates the target Flash structure too */</span>
<span class="w">    </span><span class="n">rp_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">flash</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">flash</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* calloc failed: heap exhaustion */</span>
<span class="w">        </span><span class="n">DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;calloc: failed in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="p">[...]</span>

<span class="w">    </span><span class="cm">/* Grab a member pointer to the target Flash structure */</span>
<span class="w">    </span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="n">target_flash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flash</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">;</span>
<span class="w">    </span><span class="p">[...]</span>
<span class="w">    </span><span class="cm">/* Register with the target structure */</span>
<span class="w">    </span><span class="n">target_add_flash</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">target_flash</span><span class="p">);</span>
<span class="w">    </span><span class="p">[...]</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">rp_probe</span><span class="p">(</span><span class="n">target_s</span><span class="w"> </span><span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">[...]</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * We can&#39;t know the Flash region layout head of time, so we override the target `attach` behaviour</span>
<span class="cm">     * and perform RAM and Flash region registration on attach</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">target</span><span class="o">-&gt;</span><span class="n">attach</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rp_attach</span><span class="p">;</span>
<span class="w">    </span><span class="p">[...]</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">rp_attach</span><span class="p">(</span><span class="n">target_s</span><span class="w"> </span><span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * RP2040 is a Cortex-M device, so we *must* call the normal Cortex-M attach routine and</span>
<span class="cm">     * propagate errors. It is an error to not do this step somewhere in the target-specific attach routine.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">cortexm_attach</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">rp_read_rom_func_table</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/*</span>
<span class="cm">     * Because we are in attach, which can be called multiple times for a device, we *must*</span>
<span class="cm">     * free any existing map before rebuilding it. Failure to do so will result in unpredictable behaviour.</span>
<span class="cm">     */</span>
<span class="w">    </span><span class="n">target_mem_map_free</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
<span class="w">    </span><span class="n">rp_add_flash</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
<span class="w">    </span><span class="n">target_add_ram</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">RP_SRAM_BASE</span><span class="p">,</span><span class="w"> </span><span class="n">RP_SRAM_SIZE</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The generic target Flash structure is defined as follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">target_flash</span><span class="w"> </span><span class="n">target_flash_s</span><span class="p">;</span>

<span class="k">typedef</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">flash_prepare_func</span><span class="p">)(</span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="p">);</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">flash_erase_func</span><span class="p">)(</span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="p">,</span><span class="w"> </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">flash_write_func</span><span class="p">)(</span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="p">,</span><span class="w"> </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">flash_done_func</span><span class="p">)(</span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="p">);</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">target_flash</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">target</span><span class="w"> </span><span class="o">*</span><span class="n">t</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* Target this Flash is attached to */</span>
<span class="w">    </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">start</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Start address of Flash */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w">               </span><span class="cm">/* Flash length */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">blocksize</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Erase block size */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">writesize</span><span class="p">;</span><span class="w">            </span><span class="cm">/* Write operation size, must be &lt;= blocksize/writebufsize */</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">writebufsize</span><span class="p">;</span><span class="w">         </span><span class="cm">/* Size of write buffer, this is calculated and not set in target code */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">erased</span><span class="p">;</span><span class="w">              </span><span class="cm">/* Byte erased state */</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">operation</span><span class="p">;</span><span class="w">           </span><span class="cm">/* Current Flash operation (none means it&#39;s idle/unprepared) */</span>
<span class="w">    </span><span class="n">flash_prepare_func</span><span class="w"> </span><span class="n">prepare</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Prepare for flash operations */</span>
<span class="w">    </span><span class="n">flash_erase_func</span><span class="w"> </span><span class="n">erase</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Erase a range of flash */</span>
<span class="w">    </span><span class="n">flash_write_func</span><span class="w"> </span><span class="n">write</span><span class="p">;</span><span class="w">      </span><span class="cm">/* Write to flash */</span>
<span class="w">    </span><span class="n">flash_done_func</span><span class="w"> </span><span class="n">done</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Finish flash operations */</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">;</span><span class="w">                   </span><span class="cm">/* Buffer for flash operations */</span>
<span class="w">    </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">buf_addr_base</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Address of block this buffer is for */</span>
<span class="w">    </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">buf_addr_low</span><span class="p">;</span><span class="w">  </span><span class="cm">/* Address of lowest byte written */</span>
<span class="w">    </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">buf_addr_high</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Address of highest byte written */</span>
<span class="w">    </span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span><span class="w">        </span><span class="cm">/* Next Flash in the list */</span>
<span class="p">};</span>
</pre></div>
</div>
</section>
<section id="skeleton-driver">
<h2>Skeleton Driver<a class="headerlink" href="#skeleton-driver" title="Permalink to this heading">¶</a></h2>
<p>Below is a skeleton for adding support for a new target. Please note that it is preferred to forward declare the Flash
routines and define them after <code class="docutils literal notranslate"><span class="pre">*_add_flash</span></code> and <code class="docutils literal notranslate"><span class="pre">*_probe</span></code>. Functionally it makes no difference, but this improves
the navigability of the resulting target support.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* Declare the license you wish to use here */</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;general.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;target.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;target_internal.h&quot;</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">skeleton_flash_erase</span><span class="p">(</span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="p">,</span><span class="w"> </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">skeleton_flash_write</span><span class="p">(</span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="p">,</span><span class="w"> </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">skeleton_add_flash</span><span class="p">(</span><span class="n">target_s</span><span class="w"> </span><span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">calloc</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">flash</span><span class="p">));</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">flash</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="cm">/* calloc failed: heap exhaustion */</span>
<span class="w">        </span><span class="n">DEBUG_WARN</span><span class="p">(</span><span class="s">&quot;calloc: failed in %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">__func__</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">flash</span><span class="o">-&gt;</span><span class="n">start</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SKELETON_FLASH_BASE</span><span class="p">;</span>
<span class="w">    </span><span class="n">flash</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SKELETON_FLASH_SIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">flash</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SKELETON_BLOCKSIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">flash</span><span class="o">-&gt;</span><span class="n">erase</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">skeleton_flash_erase</span><span class="p">;</span>
<span class="w">    </span><span class="n">flash</span><span class="o">-&gt;</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">skeleton_flash_write</span><span class="p">;</span>
<span class="w">    </span><span class="n">flash</span><span class="o">-&gt;</span><span class="n">erased</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffU</span><span class="p">;</span>
<span class="w">    </span><span class="n">target_add_flash</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">flash</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">skeleton_probe</span><span class="p">(</span><span class="n">target_s</span><span class="w"> </span><span class="o">*</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="cm">/* Positively identify the target device somehow */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">target_mem_read32</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">SKELETON_DEVID_ADDR</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">SKELETON_DEVID</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="n">target</span><span class="o">-&gt;</span><span class="n">driver</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;skeleton partno&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="cm">/* Add RAM mappings */</span>
<span class="w">    </span><span class="n">target_add_ram</span><span class="p">(</span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">SKELETON_RAM_BASE</span><span class="p">,</span><span class="w"> </span><span class="n">SKELETON_RAM_SIZE</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* Add Flash mappings */</span>
<span class="w">    </span><span class="n">skeleton_add_flash</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">skeleton_flash_erase</span><span class="p">(</span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="p">,</span><span class="w"> </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">[...]</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">skeleton_flash_write</span><span class="p">(</span><span class="n">target_flash_s</span><span class="w"> </span><span class="o">*</span><span class="n">flash</span><span class="p">,</span><span class="w"> </span><span class="n">target_addr_t</span><span class="w"> </span><span class="n">dest</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="p">[...]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In addition to this, you <em>must</em> declare your new probe routine in
<a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/target_probe.h"><code class="docutils literal notranslate"><span class="pre">target/target_probe.h</span></code></a>,
and also define a weak linked stub for it in
<a class="reference external" href="https://github.com/blackmagic-debug/blackmagic/blob/main/src/target/target_probe.c"><code class="docutils literal notranslate"><span class="pre">target/target_probe.c</span></code></a></p>
<p>The existing stubs should serve as a decent example for how to do this.</p>
<p>If you wish your new target support to provide functionality like mass erase, there are members in the target structure
such as <code class="docutils literal notranslate"><span class="pre">t-&gt;mass_erase</span></code> specifically for this and should be populated in your probe routine.
Similarly, if you wish to add custom commands for your target, you need to build a <code class="docutils literal notranslate"><span class="pre">command_s</span></code> structure array at the top of your target support implementation and register it in the probe routine with <code class="docutils literal notranslate"><span class="pre">target_add_commands()</span></code>.
An example of how to define this custom command block follows:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">command_s</span><span class="w"> </span><span class="n">stm32f1_cmd_list</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">{</span><span class="s">&quot;option&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">stm32f1_cmd_option</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Manipulate option bytes&quot;</span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">},</span>
<span class="p">};</span>
</pre></div>
</div>
<p>An example registration call has this form: <code class="docutils literal notranslate"><span class="pre">target_add_commands(target,</span> <span class="pre">stm32f1_cmd_list,</span> <span class="pre">target-&gt;driver);</span></code></p>
</section>
</section>

<div class="section ablog__blog_comments">
  
  
</div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/blackmagic-logo.svg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">The Plug&Play MCU Debugger</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=blackmagic-debug&repo=blackmagic&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Intro</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hardware.html">Supported Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../upgrade.html">Firmware Upgrade</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Knowledgebase</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../knowledge/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../knowledge/terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../knowledge/pinouts.html">Pinout Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../knowledge/links.html">Links</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usage/gdb-commands.html">GDB Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/gdb-automation.html">GDB Flash Automation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/semihosting.html">Semihosting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/traceswo.html">SWD - TRACESWO support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/swo.html">Serial Wire Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/rtt.html">Using RTT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/platformio.html">PlatformIO</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Target Specific Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../target-usage/stm32.html">STM32 Targets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target-usage/sam3x-4x-x7x.html">SAM3x-4x-x7x</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hacking</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="hacking.html">Firmware Hacking</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Adding Target Drivers</a></li>
<li class="toctree-l1"><a class="reference internal" href="target-cortex-m.html">Cortex-M Targets</a></li>
<li class="toctree-l1"><a class="reference internal" href="target-cortex-a.html">Cortex A Targets</a></li>
<li class="toctree-l1"><a class="reference internal" href="target-clock-generation.html">Target Clock Generation</a></li>
</ul>


<div class="ablog-sidebar-item ablog__recentposts">
<h3>
  <a href="../blog.html">Recent Posts</a>
</h3>
<ul>
  
  
  <li>
    <a href="../blog/2022-07-21-release-v1_8_2.html">
      21 July - Stable Release V1.8.2
    </a>
  </li>
  
  <li>
    <a href="../blog/2022-07-13-release-v1_8_1.html">
      13 July - Stable Release V1.8.1
    </a>
  </li>
  
  <li>
    <a href="../blog/2022-05-30-release-v1_8_0.html">
      30 May - Stable Release V1.8.0
    </a>
  </li>
  
  <li>
    <a href="../blog/2022-01-20-organization-rename.html">
      20 January - GitHub Organization Name Change
    </a>
  </li>
  
  <li>
    <a href="../blog/2022-01-07-new-maintainer.html">
      07 January - New Project Maintainer
    </a>
  </li>
  
</ul>
</div>

<div class="ablog-sidebar-item ablog__archive">
<h3>
  <a href="../blog/archive.html">Archives</a>
</h3>
<ul>
  
  
  <li>
    <a href="../blog/2022.html">2022 (5)</a>
  </li>
  
  
</ul>
</div>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="hacking.html" title="previous chapter">Firmware Hacking</a></li>
      <li>Next: <a href="target-cortex-m.html" title="next chapter">Cortex-M Targets</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022-2023, Piotr Esden-Tempski <piotr@esden.net>; 2022-2023, Rachel Mant <git@dragonmux.network>.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>