<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/svg+xml" href="../_static/favicon/icon.svg">
    <link rel="icon" sizes="16x16" type="image/png" href="../_static/favicon/favicon-16x16.png">
    <link rel="icon" sizes="32x32" type="image/png" href="../_static/favicon/favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="57x57" type="image/png" href="../_static/favicon/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" type="image/png" href="../_static/favicon/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" type="image/png" href="../_static/favicon/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" type="image/png" href="../_static/favicon/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="96x96" type="image/png" href="../_static/favicon/apple-touch-icon-96x96.png">
    <link rel="apple-touch-icon" sizes="114x114" type="image/png" href="../_static/favicon/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" type="image/png" href="../_static/favicon/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" type="image/png" href="../_static/favicon/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" type="image/png" href="../_static/favicon/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" type="image/png" href="../_static/favicon/apple-touch-icon-180x180.png">
    <link rel="android-icon" sizes="192x192" type="image/png" href="../_static/favicon/android-icon-192x192.png"><meta property="og:title" content="Cortex-M Targets" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://black-magic.org/hacking/target-cortex-m.html" />
<meta property="og:site_name" content="Black Magic Debug" />
<meta property="og:description" content="Developing a new target driver for the Black Magic Probe is straight forward on many ARM platforms. This page collects some notes taken while developing drivers. As a convention, source files are r..." />
<meta property="og:image" content="https://black-magic.org/_static/blackmagic-logo.png" />
<meta property="og:image:alt" content="Black Magic Debug" />
<meta name="description" content="Developing a new target driver for the Black Magic Probe is straight forward on many ARM platforms. This page collects some notes taken while developing drivers. As a convention, source files are r..." />

    <title>Cortex-M Targets &#8212; Black Magic Debug  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=039e1c02" />
    <link rel="stylesheet" type="text/css" href="../_static/graphviz.css?v=eafc0fe6" />
    <link rel="stylesheet" type="text/css" href="../_static/asciinema-player_2.6.1.css" />
    <link rel="stylesheet" type="text/css" href="../_static/asciinema-custom.css" />
    <link rel="stylesheet" type="text/css" href="../_static/platformpicker.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=16ad857a"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script src="../_static/asciinema-player_2.6.1.js"></script>
    <script src="../_static/platformpicker.js"></script>
    <link rel="canonical" href="https://black-magic.org/hacking/target-cortex-m.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Cortex A Targets" href="target-cortex-a.html" />
    <link rel="prev" title="Adding Target Drivers" href="target-drivers.html" />

   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />


<link
  rel="alternate"
  type="application/atom+xml"
  href="../blog/atom.xml"
  title="Blog"
/>



  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
<section id="cortex-m-targets">
<h1>Cortex-M Targets<a class="headerlink" href="#cortex-m-targets" title="Permalink to this heading">¶</a></h1>
<p>Developing a new target driver for the Black Magic Probe is straight forward on many ARM platforms.
This page collects some notes taken while developing drivers.
As a convention, source files are referenced from the top level directory of the repository with a dot (.)
so the directory for target files is <code class="docutils literal notranslate"><span class="pre">./src/target</span></code>.</p>
<section id="hooking-your-target-support-into-the-system">
<h2>Hooking your target support into the system<a class="headerlink" href="#hooking-your-target-support-into-the-system" title="Permalink to this heading">¶</a></h2>
<p>Your driver will typically be written in a single source file which should be in the <code class="docutils literal notranslate"><span class="pre">./src/target</span></code> directory
and named after the family you wish to add support for.
For example, support for the ST Micro STM32F1 series are in the file <code class="docutils literal notranslate"><span class="pre">src/target/stm32f1.c</span></code></p>
<p>This file will define exactly one globally visible function named <code class="docutils literal notranslate"><span class="pre">&lt;target&gt;_probe</span></code> with the C prototype of
<code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">&lt;target&gt;_probe(target</span> <span class="pre">*t);</span></code>. Any other functions or data you declare in this file should be declared
<code class="docutils literal notranslate"><span class="pre">static</span></code> to avoid name collisions with other target implementations.</p>
<p>You will modify four files to make your target part of the BMP build, the first is the make file, <code class="docutils literal notranslate"><span class="pre">./src/Makefile</span></code>
which should have your source added to the <code class="docutils literal notranslate"><span class="pre">SRC</span> <span class="pre">=</span></code> definition.The second is <code class="docutils literal notranslate"><span class="pre">./src/target/cortexm.c</span></code> where you will
add a line of the form <code class="docutils literal notranslate"><span class="pre">PROBE(&lt;target&gt;_probe);</span></code> in the sequence of other calls to probe functions.
The third file will be <code class="docutils literal notranslate"><span class="pre">./src/target/target_probe.h</span></code> where you will add a prototype for your probe function.
Finally <code class="docutils literal notranslate"><span class="pre">./src/target/target_probe.c</span></code> where you will use the <code class="docutils literal notranslate"><span class="pre">TARGET_PROBE_WEAK_NOP</span></code> macro to add a weak linked
stub for your probe function.</p>
<p>A typical target driver will be updates to these four files and your new <code class="docutils literal notranslate"><span class="pre">./src/target/&lt;target&gt;.c</span></code> file.</p>
</section>
<section id="setting-up-a-development-environment">
<h2>Setting up a Development Environment<a class="headerlink" href="#setting-up-a-development-environment" title="Permalink to this heading">¶</a></h2>
<p>You will need three things for a functioning development environment: GNU Make, bmputil, and a compiler.
If you wish to interface with the target serial port having built the firmware with debugging enabled,
then you will also need to install a serial program such as minicom or screen.</p>
<p>We advise using the official ARM toolchain even over any distribution toolchain you might be able to install
from a package manager. You can acquire the official toolchain in one of two flavours - the older
<a class="reference external" href="https://developer.arm.com/downloads/-/gnu-rm">GNU Arm Embedded Toolchain</a> flavour,
and the newer <a class="reference external" href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads">Arm GNU Toolchain</a> flavour.
Both should work, however the project authors currently test with and use the older toolchain flavour.</p>
<p>The Black Magic Firmware supports two kinds of debugging, however, using them may require disabling some target
support to free up enough Flash space for the extra code and data needed. The first kind of debugging uses
debug statements littered through the code and the secondary serial connection. You can enable this by passing
<code class="docutils literal notranslate"><span class="pre">ENABLE_DEBUG</span></code> to the build, as in <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">ENABLE_DEBUG=1</span></code>. The second kind of debugging is for Black Magic Inception
and involves switching to debug optimisations and enabling debug information generation in the build. This can be
achieved by passing <code class="docutils literal notranslate"><span class="pre">OPT_FLAGS</span></code> to the build, as in <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">OPT_FLAGS=&quot;-Og</span> <span class="pre">-g&quot;</span></code> – these approaches are not mutually
exclusive of each other and can both be enabled at the same time by combining the make arguments:
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">ENABLE_DEBUG=1</span> <span class="pre">OPT_FLAGS=&quot;-Og</span> <span class="pre">-g&quot;</span></code>.</p>
<p>If instead of trying to do debug builds to fit in Flash you need a more general approach and <strong>do not</strong> need to debug
the JTAG or SWD bitbanging routines, you can alternatively use BMDA (Black Magic Debug App) which carries none
of the restrictions of the firmware. To do this, simply build with the following options to Make:
<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">PROBE_HOST=hosted</span> <span class="pre">ENABLE_DEBUG=1</span> <span class="pre">ASAN=1</span> <span class="pre">OPT_FLAGS=&quot;-Og</span> <span class="pre">-g&quot;</span></code>.
Even though <code class="docutils literal notranslate"><span class="pre">ASAN=1</span></code> is optional, it is <em>strongly</em> advised you enable this when doing development on BMP.</p>
<p>With the firmware variant, once you have a debug-enabled build you can connect to the BMP’s non-GDB serial port
to get the additional debug messages. The extra messages are only enabled if you issue <code class="docutils literal notranslate"><span class="pre">monitor</span> <span class="pre">debug_bmp</span> <span class="pre">enable</span></code>
(or a shortening such as <code class="docutils literal notranslate"><span class="pre">mon</span> <span class="pre">debug</span> <span class="pre">en</span></code>) from in GDB after connecting in to your BMP as normal. Alternatively, you
can set up Black Magic Inception, detailed in the following section.</p>
</section>
<section id="black-magic-inception">
<h2>Black Magic Inception<a class="headerlink" href="#black-magic-inception" title="Permalink to this heading">¶</a></h2>
<p>There are a couple of generations of this. The older generation (v2.0 hardware and older) uses the auxiliary
serial connector on BMP which happens to be directly attached to the SWD pins of the processor on BMP, and
the newer generation (v2.1 hardware and newer) has a dedicated pinheader connector for the purpose.</p>
<section id="debugging-the-older-generation">
<h3>Debugging the older generation<a class="headerlink" href="#debugging-the-older-generation" title="Permalink to this heading">¶</a></h3>
<p>With the older generation (v2.0 hardware and older), you can debug a new BMP target with a second BMP as
the first BMP’s debugger. When debugging with another BMP device the debug messages who up in the second
BMP devices gdb session as it uses semi-hosting to direct them out.</p>
<p>To set up one BMP debugging a second BMP is not particularly difficult but it can be unwieldy. Start with the
BMP that is going to run the new target code, connect its SWD, SCLK, tPWR/vRef, and GND pins on the PicoBlade
connector on the rear side of the board, to the second BMP unit. If you have the mini-10 to JTAG adapter board
and a PicoBlade serial port cable, you can push the connectors on the serial port cable on to the pins on the
10-pin debug target connector.</p>
<p>The connection sequence from the PicoBlade
(with the <a class="reference external" href="https://1bitsquared.com/products/black-magic-01in-pin-header-serial-cable">1BitSquared cable</a>)
to the 10-pin debug target connector is:</p>
<ul class="simple">
<li><p>PicoBlade Pin 1 (red) =&gt; 10-pin connector pin 1</p></li>
<li><p>PicoBlade Pin 2 (green) =&gt; 10-pin connector pin 4</p></li>
<li><p>PicoBlade Pin 3 (purple) =&gt; 10-pin connector pin 2</p></li>
<li><p>PicoBlade Pin 4 (black) =&gt; 10-pin connector pin 3 or 5</p></li>
</ul>
<p>For more information on what connections are being made here, see the <a class="reference internal" href="../knowledge/pinouts.html"><span class="std std-doc">pinout glossary</span></a>.</p>
<p>If you are using an older generation BMP that uses the 20-pin ARM debug connector, you will instead want to connect
the green wire to pin 9 of the JTAG connector, purple to pin 7, and black to any even pin on the JTAG connector
other than pin 2.</p>
<p>If you set one BMP to debug another, then you can load firmware using GDB into the BMP. If you are simply building
the firmware and evaluating its function by reading the output from <code class="docutils literal notranslate"><span class="pre">DEBUG_*</span></code> statements then you will need to use
<code class="docutils literal notranslate"><span class="pre">bmputil</span></code> or <code class="docutils literal notranslate"><span class="pre">dfu-util</span></code> to update the firmware. (see <a class="reference internal" href="../upgrade.html"><span class="std std-doc">Updating the Firmware</span></a>).</p>
</section>
<section id="debugging-newer-generations">
<h3>Debugging newer generations<a class="headerlink" href="#debugging-newer-generations" title="Permalink to this heading">¶</a></h3>
<p>With newer generation (v2.1 hardware and newer) BMPs, there is a dedicated set of 0.05” (1.27mm) pin headers
provided to allow connecting one BMP to another using a
<a class="reference external" href="https://1bitsquared.com/collections/accessories/products/jtag-swd-adapter">1BitSquared JTAG SWD adaptor</a>
or the 5-pin variant of this which includes the ~RST signal too.</p>
<p>To use this, simply plug the adaptor in as labeled on the BMP you want to debug, connect a 10-pin IDC cable between it
and the second BMP you are using as the first’s debugger, and proceed as you would on the older generation boards.</p>
</section>
</section>
<section id="implementing-the-driver">
<h2>Implementing the Driver<a class="headerlink" href="#implementing-the-driver" title="Permalink to this heading">¶</a></h2>
<p>The first step in implementing the driver is to implement the <code class="docutils literal notranslate"><span class="pre">&lt;target&gt;_probe</span></code> function. This function has three very important things to do:</p>
<ol class="arabic simple">
<li><p>it has to identify whether or not you are talking to a target you recognize</p></li>
<li><p>it has to create a memory map describing that target’s resources</p></li>
<li><p>it has to initialize the function pointers in the target structure to point to routines that can erase and program the target’s on board flash memory.</p></li>
</ol>
<p>The functions <code class="docutils literal notranslate"><span class="pre">target_mem_read32</span></code> and <code class="docutils literal notranslate"><span class="pre">target_mem_write32</span></code> will read and write long words in the target’s address space. Generally the debug unit has access to all of the address space unless the chip has been put into a protected mode. It is useful for your target driver to provide a target specific command for removing protected mode (see <strong>Custom Commands</strong> below). The register that the probe code will read on Cortex-M processors is called the chip ID register or CHIPID. Where it is in the address space will be documented in the data sheet or reference manual for the chip.</p>
<p>That section will also typically document what memory configurations are available based on information contained in the CHIPID register. Your probe function will use this information to confirm that the target is something you recognize, and then decode the parameters in register according to the datasheet to identify FLASH address location and size, and RAM address location and size.</p>
<section id="adding-ram">
<h3>Adding RAM<a class="headerlink" href="#adding-ram" title="Permalink to this heading">¶</a></h3>
<p>For each discontinuous region of RAM your code will call <code class="docutils literal notranslate"><span class="pre">target_add_ram</span></code> with the pointer to the target structure, the address of the RAM chunk, and its size in bytes. Each time you call this function, an additional chunk of RAM is added to the gdb memory map for the target.</p>
</section>
<section id="adding-flash">
<h3>Adding Flash<a class="headerlink" href="#adding-flash" title="Permalink to this heading">¶</a></h3>
<p>As you did with RAM, you will need to tell gdb about the size(s) and addresses of programmable read-only memory (Flash) on the device. Because every device tends to have a slightly different way of programming things, adding a segment of Flash memory means adding the address and size of Flash, and then adding pointers to functions that can erase and write the Flash (reading is handled by just reading memory).</p>
<p>Some Flash memories can only be erased all at once, some can be erased in variable sized sectors, and others can be erased in pages of fixed size. A <em>region</em> is Flash at a given address, and of a given length, that has the same erase and programming requirements.</p>
<p>You describe these in your target driver by populating a <code class="docutils literal notranslate"><span class="pre">target_flash</span></code> structure. This structure has members for the start, length, and blocksize of the Flash you are describing. The blocksize is the smallest individual unit of Flash that can be <strong>erased</strong>. So if your Flash says that it must be erased in 8K byte segments, then your blocksize is 8192. If your Flash can be erased a page at a time and a page is 256 bytes, then your blocksize is 256. You finish that off by adding a function call to a local, statically defined, function that can erase Flash. It will be passed an address and a length which is compatible with your stated blocksize when your Flash needs to be erased.</p>
<p>The next section of this structure is for writing. It is simplest to set the write function call to the internal BMP function called <code class="docutils literal notranslate"><span class="pre">target_flash_write_buffered</span></code>. For the done function you set it to the internal function <code class="docutils literal notranslate"><span class="pre">target_flash_done_buffered</span></code>. Now you set the value <code class="docutils literal notranslate"><span class="pre">bufsize</span></code> to be the “writable unit” of Flash (so one sector or one page depending on the Flash) and the field <code class="docutils literal notranslate"><span class="pre">erased</span></code> to the state Flash is in when it is erased (typically 0xff).
Finally you will add a local, statically defined, function call which can write one buffer’s worth of data to the Flash. That function will be passed an address on a buffer boundary, and a buffer’s worth of data to write.</p>
<p>Then you will add the Flash segment by calling <code class="docutils literal notranslate"><span class="pre">target_add_flash</span></code> with the target pointer and a pointer to your <code class="docutils literal notranslate"><span class="pre">target_flash</span></code> structure.</p>
</section>
<section id="custom-commands">
<h3>Custom Commands<a class="headerlink" href="#custom-commands" title="Permalink to this heading">¶</a></h3>
<p>You have the option to add some additional commands to the target. These will become part of the acceptable commands to the ‘mon’ command in gdb. So if you added a new command <code class="docutils literal notranslate"><span class="pre">erase-protection</span></code>, typing <code class="docutils literal notranslate"><span class="pre">mon</span> <span class="pre">erase-protection</span></code> would invoke it.</p>
<p>Commands are added using a <code class="docutils literal notranslate"><span class="pre">command_s</span></code> structure of three pointers, the first is the string for the command, the second pointer is a pointer to the local function that implements that command, and the third is a help string that is printed when someone types <code class="docutils literal notranslate"><span class="pre">mon</span> <span class="pre">help</span> <span class="pre">&lt;your-command&gt;</span></code>.</p>
<p>When invoked, your command function will be passed an argument count and an argument vector (just like <code class="docutils literal notranslate"><span class="pre">main</span></code> in a C program) that you can take arguments from and use in your command. If you don’t recognize the arguments you can use <code class="docutils literal notranslate"><span class="pre">tc_printf</span></code> to return a usage string to the user.</p>
<p>If the command fails you should return <code class="docutils literal notranslate"><span class="pre">false</span></code> and if it succeeds you should return <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
</section>
</section>
<section id="special-handling">
<h2>Special Handling<a class="headerlink" href="#special-handling" title="Permalink to this heading">¶</a></h2>
<p>If you have recognized the target, filled out the <code class="docutils literal notranslate"><span class="pre">target_s</span></code> structure for it, populated the memory map and potentially added a new command or two, the final steps are to set the name of your driver in the <code class="docutils literal notranslate"><span class="pre">driver</span></code> string pointer of the target structure and decide if you need any special reset handling. Special reset handling comes in two forms, avoiding system reset and extra care after reset.</p>
<p>Some targets can lose debugger state and detach if you assert system reset. This is not supposed to happen according to the ARM documents but it has been known to be an issue. You can tell the generic Cortex M driver not to use sRST by setting an option <code class="docutils literal notranslate"><span class="pre">CORTEXM_TOPT_INHIBIT_SRST</span></code> in the <code class="docutils literal notranslate"><span class="pre">target_options</span></code> field of the target structure. Normally when the BMP is trying to reset the target it will call <code class="docutils literal notranslate"><span class="pre">platform_srst_set_val</span></code> with a <code class="docutils literal notranslate"><span class="pre">true</span></code> state followed by a <code class="docutils literal notranslate"><span class="pre">false</span></code> state to assert reset. If you find this causes your target to detach or get lost, use the <code class="docutils literal notranslate"><span class="pre">CORTEXM_TOPT_INHIBIT_SRST</span></code> option to tell the generic driver not to do that. You need only set the option in your <code class="docutils literal notranslate"><span class="pre">target_options</span></code> during the probe function.</p>
<p>Another situation that can arise is that asserting reset causes other things to happen on the chip that will prevent it from continuing. The Atmel SAM series tends to have this sort of problem. If your platform needs some extra help to get completely out of reset you can define a function that will do that work and put a pointer to it in the field <code class="docutils literal notranslate"><span class="pre">extended_reset</span></code>. If this field is non-NULL, the Cortex M platform driver will call it after it has issued a SYSRESETREQ and before it starts polling the target to see if it has released from reset.</p>
</section>
<section id="getting-from-zero-to-sixty">
<h2>Getting from Zero to Sixty<a class="headerlink" href="#getting-from-zero-to-sixty" title="Permalink to this heading">¶</a></h2>
<p>When you start this process you will have a data sheet, a fresh build the BMP firmware, and a lot of questions. Bring up strategy for a new target works well if you proceed in the following way;</p>
<ol class="arabic simple">
<li><p><strong>Verify you can identify your target</strong> – When you run your firmware for the first time attached to your target you should be able to type <code class="docutils literal notranslate"><span class="pre">mon</span> <span class="pre">swdp_scan</span></code> and see your driver name come back as the available target. If you added <code class="docutils literal notranslate"><span class="pre">DEBUG</span></code> statements to your poll function they would appear on the debug terminal (either the second serial port or the debugging BMP’s gdb session).</p></li>
<li><p><strong>Verify you can Erase and Program Flash</strong> – This is a bit trickier, one technique is to create a simple C program with some <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">unint8_t</span></code> arrays that contain recognizable data in them. Loading that file from gdb will tell the BMP to flash it into your target and you can use the gdb memory inspection tools to verify it arrived intact. A useful gdb command here is <code class="docutils literal notranslate"><span class="pre">compare-sections</span></code> which will compare the .elf file with what gdb can see in memory. If they don’t match your flash programming is <em>not working</em>. You can dump out memory to a file using the gdb command <code class="docutils literal notranslate"><span class="pre">dump</span> <span class="pre">bin</span> <span class="pre">memory</span> <span class="pre">&lt;filename&gt;</span> <span class="pre">addr1</span> <span class="pre">addr2</span></code> so the first 8K of memory might be <code class="docutils literal notranslate"><span class="pre">dump</span> <span class="pre">bin</span> <span class="pre">mem</span> <span class="pre">8k-mem-dump.bin</span> <span class="pre">0x0</span> <span class="pre">0x2000</span></code>.</p></li>
<li><p><strong>Verify you can start and interrupt a running program.</strong> – At this point it is quite useful to have a minimal “blinker” program that will toggle and LED or GPIO pin that you can monitor on an oscilloscope ready to run. Load this program with the working flash functions and tell gdb to run it. It should start and the GPIO should begin toggling, then use ^C to interrupt and verify the program stops and gdb gives you the source line where the code was interrupted.</p></li>
<li><p><strong>Verify you can set a breakpoint and single step.</strong> – If you have a runnable “Blinky” program then you can set a breakpoint on the <code class="docutils literal notranslate"><span class="pre">main</span></code> function. Run the program and confirm that it stops when it hits the break point. Use the <code class="docutils literal notranslate"><span class="pre">step</span></code> command to single step forward and then the <code class="docutils literal notranslate"><span class="pre">cont</span></code> command to resume execution.</p></li>
</ol>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this heading">¶</a></h2>
<p>Implementation of a new Cortex-M target driver requires that you write code that can positively identify that your target is being talked to, erase and program your target’s FLASH memory, manage resets so that the debugger can function across system resets, and any special commands that might be needed for target-specific features. You can debug the development through either <code class="docutils literal notranslate"><span class="pre">printf</span></code> like features of the DEBUG statements or by using another BMP to run gdb on the firmware in the first one. Using a simple “blinky” type program and some recognizable data structures you can verify the basic functions of gdb with respect to your target.</p>
<p>Once you’ve done that you have a new target driver for the BMP.</p>
</section>
</section>

<div class="section ablog__blog_comments">
  
  
</div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../index.html">
    <img class="logo" src="../_static/blackmagic-logo.svg" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">The Plug&Play MCU Debugger</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=blackmagic-debug&repo=blackmagic&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Intro</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../hardware.html">Supported Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting-started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../upgrade.html">Firmware Upgrade</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Knowledgebase</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../knowledge/faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../knowledge/terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../knowledge/pinouts.html">Pinout Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../knowledge/links.html">Links</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../usage/gdb-commands.html">GDB Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/gdb-automation.html">GDB Flash Automation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/semihosting.html">Semihosting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/traceswo.html">SWD - TRACESWO support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/swo.html">Serial Wire Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/rtt.html">Using RTT</a></li>
<li class="toctree-l1"><a class="reference internal" href="../usage/platformio.html">PlatformIO</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Target Specific Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../target-usage/stm32.html">STM32 Targets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../target-usage/sam3x-4x-x7x.html">SAM3x-4x-x7x</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Hacking</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="contrib.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="hacking.html">Firmware Hacking</a></li>
<li class="toctree-l1"><a class="reference internal" href="target-drivers.html">Adding Target Drivers</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Cortex-M Targets</a></li>
<li class="toctree-l1"><a class="reference internal" href="target-cortex-a.html">Cortex A Targets</a></li>
<li class="toctree-l1"><a class="reference internal" href="target-clock-generation.html">Target Clock Generation</a></li>
</ul>


<div class="ablog-sidebar-item ablog__recentposts">
<h3>
  <a href="../blog.html">Recent Posts</a>
</h3>
<ul>
  
  
  <li>
    <a href="../blog/2022-07-21-release-v1_8_2.html">
      21 July - Stable Release V1.8.2
    </a>
  </li>
  
  <li>
    <a href="../blog/2022-07-13-release-v1_8_1.html">
      13 July - Stable Release V1.8.1
    </a>
  </li>
  
  <li>
    <a href="../blog/2022-05-30-release-v1_8_0.html">
      30 May - Stable Release V1.8.0
    </a>
  </li>
  
  <li>
    <a href="../blog/2022-01-20-organization-rename.html">
      20 January - GitHub Organization Name Change
    </a>
  </li>
  
  <li>
    <a href="../blog/2022-01-07-new-maintainer.html">
      07 January - New Project Maintainer
    </a>
  </li>
  
</ul>
</div>

<div class="ablog-sidebar-item ablog__archive">
<h3>
  <a href="../blog/archive.html">Archives</a>
</h3>
<ul>
  
  
  <li>
    <a href="../blog/2022.html">2022 (5)</a>
  </li>
  
  
</ul>
</div>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
      <li>Previous: <a href="target-drivers.html" title="previous chapter">Adding Target Drivers</a></li>
      <li>Next: <a href="target-cortex-a.html" title="next chapter">Cortex A Targets</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022-2023, Piotr Esden-Tempski <piotr@esden.net>; 2022-2023, Rachel Mant <git@dragonmux.network>.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>